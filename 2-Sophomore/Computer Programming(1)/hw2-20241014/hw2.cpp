#include <iostream>
#include <vector>
#include <algorithm> // gcdを使うために必要
using namespace std;

int main() {
    int n;
    cin >> n;  // nの入力

    vector<int> a(n);  // 配列aの定義
    for (int i = 0; i < n; ++i) {
        cin >> a[i];  // 配列aの入力
    }

    vector<int> b;  // 結果を格納する配列b

    // ⌊n/2⌋まで繰り返し
    for (int j = 0; j < n / 2; ++j) {
        // a[j]とa[n-1-j]の最大公約数(GCD)を計算
        int gcd_value = (a[j], a[n - 1 - j]);
        b.push_back(gcd_value);  // 結果をbに追加
    }

    // 結果の出力
    for (int i = 0; i < b.size(); ++i) {
        cout << b[i] << " ";
    }
    cout << endl;

    return 0;
}

// おっしゃる通り、配列のインデックス指定で後ろから数える場合は、a[n - 1 - j] が正しい表現です。n+1-j としてしまうとインデックスが範囲外になり、意図した位置を取得できなくなります。

// なぜ a[n - 1 - j] なのか
// C++ の配列や std::vector のインデックスは 0から始まるため、インデックスを指定するときには次のように計算します：

// n は配列の要素数であり、インデックスの最大値は n-1 です。
// 前から j 番目の要素 a[j] に対して、後ろから対応する要素は a[n - 1 - j] で表せます。
// 例を使った説明
// 例えば、配列 a = [a1, a2, a3, ..., a10] が与えられたとき、n = 10 とします。

// j = 1 の場合：

// 前から j = 1 の要素は a[1] です。
// これに対応する後ろからの要素は a[n - 1 - 1] = a[10 - 1 - 1] = a[8] です。
// j = 2 の場合：

// 前から j = 2 の要素は a[2] です。
// 対応する後ろからの要素は a[n - 1 - 2] = a[10 - 1 - 2] = a[7] です。
// このように、a[n - 1 - j] を使うことで、前から数えた要素 aj に対応する後ろからの要素が正確に取得できます。
